# hw3
## q1
一个ndarray正常来说,包含以下几个元素  
1.数据存储本身  
2.shape 用于标记矩阵形状,对于切片矩阵,shape不需要与存储本身大小对应  
3.stride 用于矩阵元素位置的计算,即a[i][j] = i * stride[0] + j * stride[1]
- 正常矩阵 stride元组从后往前,分别是shape从后往前的相乘,再乘单个数据所占大小
- 切片矩阵的stride与总的存储数据不完全对应
- 切片矩阵本身的shape和stride计算之后与总的存储数据不完全对应,所以需要进行compact操作,虽然计算可以用,但是进行逐元素操作的时候,会损失数据局部性  
4.广播操作对于stride,只需要把shape中为1的且需要广播的维度stride置为0即可,原理是广播不需要真正对数据进行复制,只是通过修改shape和stride让你感觉在取下标的时候,渠道一样的数据即可,所以广播维度的stride不需要算到索引上

对于这些操作本身来说,除了compact操作之外,其他的操作都不需要进行数据存储层面的修改,只需要对shape,stride,offset修改即可

所以  
1.reshape 需要修改shape,之后再求得新stride使用辅助函数as_stride
2.permute 按照索引轮换对应的shape和stride即可  
3.broadcast_to 首先要保证新shape要么等于原shape,要么是1,之后将不与原shape相等的维度,即为1需要广播的维度的stride,设为0  
4.get_item shape直接拿前后索引差除以step,stride用旧的stride乘上step,offset指的是每个维度最开始的索引,内层的start要加上所有外层的start,是一个规约算法

## q2
1.将一个非紧凑型矩阵转换为紧凑型矩阵,给出了原矩阵, 紧凑后的shape,stride,offset  
构建类似shape的索引向量,类似高精度加法的方式,每次迭代将向量从后往前加1,需要进位.  在根据索引来利用公式a[i][j] = offset+a[i]*stride[i]+a[j]*stride[j]计算出要填入的数值在原矩阵中的位置.对紧凑型矩阵进行for循环即可  
2.将一个紧凑矩阵赋值给一个非紧凑型矩阵,即将1调换位置即可  
3.将标量赋值给紧凑矩阵,类似2

## q3
逐元素相乘的函数,实现比较简单

## q4  
规约,只是一维隔一段区间对这一段区间规约

## q5  
分块矩阵乘法,两个函数,外部对矩阵进行分块切分,内部对分块的同样大小矩阵进行矩阵乘法  
1.切分:这里不是只按行列进行切分,而是把某一正方形块的元素聚合成一个分块矩阵,相当于将整个矩阵元素分块聚合了,所以mxn,nxp,变为(m/Txn/T)xTxT,但是这里存储方式不是行主列了,而是分块之间行主列,分块内部再行主列,两个元素横向相邻,但属于不同分块就不在一起  
分块后,行的序列上限是m/T,列的序列上限是p/T,对于每块的索引,按照分块内外分别行主序存储的话,分块外行索引 (i*(n/T))是前面所有行分块数量,k是当前行分块数量,两个相加乘上TxT.矩阵右元的行索引是(k*(p/T)),列索引就是j本身,最后再乘上TxT
```cpp
  for (uint32_t i=0; i<m/TILE; i++) {
    for (uint32_t j=0; j<p/TILE; j++) {
      for (uint32_t k=0; k<n/TILE; k++) {
        AlignedDot(a.ptr + (i*n/TILE + k)*TILE*TILE, 
        b.ptr + (k*p/TILE + j)*TILE*TILE, 
        out->ptr + (i*p/TILE + j)*TILE*TILE);
      }
    }
  }
```  
2.分块内部矩阵相乘就是很简单的两个方块矩阵相乘,提前需要用函数对齐

